
# entering input
x <- 1
print(x)
#1
x
msg <- "hello"
#"hello"

#evaluation
x <- 5 ## nothing printed
x 
print(x)  ## prints x   the [1] indicates that x ia  VWXTOR ns 5 ia thew dirst wlwmwnt

#Printing
x <- 1:20
x
# the : is used to create integer sequences

##creating vectors
x <- c(0.5, 0.6)	##NUMERIC
x<- c(TRUE, FALSE)##LOGICAL
x <- c(T,F)		## LOGICAL
x <- c("a","b","c")## CHARACTER
x <- 9:29		## INTEGER
x <- c(1+0I, 2+4I)## COMPLEX

#USING THE VECTOR () FUNCTION

x <- vector("numeric", length = 10)
x
#[1] 000000000

#Mixing objects
 y <- c(1:7,"a")  ##charater
y <- TRUE, 2)     ## numeric
y <- c("a", TRUE)   ## character
## when different objects are mixed in a vector coercion occurs tath
## every element in the vector is of the same class

## explicit Coercion

 x <- 0:6
class(x)
##[1] "integer"
as.numeric(x)
##[1] 0 1 2 3 4 5 
as.logical(x)
##[1] FALSE TRUE TRUE TRUE TRUE ...

as.character(x)
##[1] "0" "1" "2" 

##Explicit Coercion data types part 2 9:45
x <- c("a", "b", "c")
as.numeric(x)
as.logical(x)
as.complex(x)

## matrices
m<- matrix(nrow = 2, ncol = 3)  
m
dim(m)
attributes(m)
$dim

##matrices contd
m<- matrix( 1:6, nrow = 2 , ncol = 3)
m
##matrices are constructed column wise so entries can be thought or ==of starting in the upper ;eft cprner

##matrices cont
m <- 1:10
m
dim(m) <- c(2,5)
m

##cbinding and rbinding
x <- 1:3
y <- 10:12
cbind(x,y)
rbind(x,y)

## lists
## lists are a special type of vector that can contain elements of different classees. lists are
##a important tyoe data type in R an you should get to know them well
x<- list(1, "a", TRUE, 1+ 4i)
x
##[[1]]
##[[2]]
##[[3]]
##[[4]]

##Factors
x <- factor(c("yes", "yes", "no", "yes", "no"))
x
table(x)
x
unclass(x)
attr(,"Levels")## watch the capitalization


##Factors
## the order of the levels can be set using the levels argument to factor(). This can e important in 
##linear modeling because the first level os uded as the baseline level
x <- factor( c( "yes","yes", "no","yes","no"), 
levels = c("yes", "no"))
x

## nmissing values
##na and nan  has a class also  integer and character
##is.na()
##is.nan()
x <- c(1,2,NA,10,3) 
is.na(x)
is.nan(x)
x <- c(1,2,NaN, NA,4)
is.na(x)
is.nan(x)
is.NaN(x) ##spelling

## data frames
x <- data.frame(foo = 1:4, bar = c(T, T, F, F))
x
nrow(x)
ncol(x)

##names
## r objects can also have names which is verty useful for writing readavel code and self describing objects
x <- 1:3
names(x)
names(x) <- c("foo", "bar", "norf")
x
names(x)

##Names
#lists can also have names
x <- list(a=1,b=2,c=3)
x
##Names and matrices
m <- matrix(1:4, nrow = 2, ncol = 2)
dimnames(m) <- list(c("a","b"),c("c","d"))
m

##subsetting   part 1 701
##[ always returns an object of the same class as he original can be used to select more tahn one ele,emt
## there is one exception
##    [[ is used to extract elements of a list or a data frame it can only be used to extraact a single
##  element and the class of the returned obhect will not necessarly be a list or data frame
##  $ is used to extract elements of a list or data freme by name semantics are similar to that of [[

##Subsetting
x <- c("a","b","c","c","d","a")
x[1]
x[2]
x[1:4]
x[x>"a"]
u <- x > "a"
u
x[u]

##subsetting a matrix
##  matrices can be subsetted in the usual way with (i,j) type indices
x <- matrix(1:6, 2, 3)
x[1,2]
x[2.1]
##indices can also be missing
x[1,]
x[,2]

## subsetting a matrix
## by default whebn a single element of a matrix is retrived it is returned as a vector of length 1 rather
## than a 1 x1 matrix this behavior can be turned off by settig drop = false
x <- matrix(1:6, 2, 3)
x[1,2]
x[1,2,drop = FALSE]

## subsetting a matrix
## similary subsetting a singell column or a single rowe will give tou a vector not a matrix by deafaut
x <- matrix(1:6,2,3)
x[1,]
x[1,,drop= FALSE]

##subsetting list
6/14
##subsetting lists
x<- list(foo=1:4, bar =.6)
x[1]
x[[1]]
x$bar
x[["bar"]]
x["bar"]
$bar   ## get an error with this

## subsetting lists
x <- list(foo = 1:4, bar = 0.6, baz = "hello")
x[c(1,3)]
$foo
$baz

##subsetting lists
##the [[ operator can be used with computed indices $ can only be used with literal names
x<- list(foo = 1:4, bar = 0.6, bax = "hello")
name <- "foo"
x[[name]]  ## computed index for "foo"
x$name   ## element name sdoesn't exist
x$foo    ## element foo does exist

## subsetting nested elements of a list
## the [[can take and integer sequence
x <- list(a = list(10, 12, 14), b= c(3.14, 2, 2.81))
x[[c(1,3)]]
x[[1]][[3]]
x[[c(2.1)]]

## partial matching
x <- list(aardvark = 1:5)
x$a
x[["a"]]
x[["a", exact = FALSE]]

##removing na values
##a common tasl os tp remove miassing values NAS
x <- c(1,2,NA,4,NA,5)
bad <- is.na(x)
x[!bad]


##removing na values
##what if there are multiple things and tou want to rake the subset with no missing values
x <- c(1,2,NA,4,NA,5)
y <- c("a","b", NA,"d", NA, "f")
good <- complete.cases(x , y)
good
x(good)
y(good)
# something wrong - getting error

## removing na values
airquality[1:6, 1]
good <- complete.cases(airquality)
airquality[good,][1:6]

##reading in larger datasets with read.table
inital <- read.table("datatable.txt", nrows=100)
classes <- sapply9initial, class)
tabAll <- read.table("detatable.txt", colClasses = classes)

##setting sset rows to a limit helps with memory

## dput-ting R objects
## another way to pass data around is by deparsing the R object with dput and reading it back in uaing dget
y <- data.frame(a=1, b= "a")
dput(y)
structure(list(a = 1,
b = structure(1L, .Label = "a",
class = "factor")),
.Names = c("a","b"), row.names = c(NA, -1L),
class = "data.frame")
dput(y, file = "y.R")
new.y <- dget("y.R")
new.y
 

##Dumping R objects
x <- "foo"
y <- data.frame(a=1, b = "a")
y <- dump(c("x","y"), file = "data.R)
rm(x,y)
source("data.R")
y
x

## reading lines of a text file
con <- gzfile("words.gz")
x <- readLines(con, 10)
x
# writeLines takes a character vector and writes each element one line at a time to a text file


# 
##reading lines of a text file
##readlines can be useful for reading in lines of webpages
##this might take time
con <- url("http://www.jhsph.edu", "r")
x <- readLines(con)
head(x)
##reading and writing data part 2 9:30

